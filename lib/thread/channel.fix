// A Channel that can be used for the communication of threads.
module Minilib.Thread.Channel;

import AsyncTask;
import RingBuffer;

import Minilib.Monad.IO;

// A Channel that can be used for the communication of threads.
type Channel a = unbox struct {
    var: Var (ChannelData a)
};

// The channel data
type ChannelData a = unbox struct {
    queue: RingBuffer a,     // the queue
    closed: Bool        // true iff the channel is closed
};

// `Channel::make` creates a new channel.
make: [m: MonadIO] m (Channel a);
make = lift_io $ do {
    pure();;        // make it lazy
    let chan_data = ChannelData {
        queue: RingBuffer::create([]),
        closed: false
    };
    let var = *Var::make(chan_data);
    pure $ Channel { var: var }
};

// `channel.clear` clears the queue of the channel.
clear: [m: MonadIO] Channel a -> m ();
clear = |chan| lift_io $ do {
    chan.@var.mod(set_queue(RingBuffer::create([])))
};

// `channel.take_and_clear` takes all items away from the queue of the channel
// and clears the queue.
// This function can be used after the channel is closed.
take_and_clear: [m: MonadIO] Channel a -> m (DynIterator a);
take_and_clear = |chan| lift_io $ do {
    chan.@var.lock(
        |data|
        let queue = data.@queue;
        let iter = Iterator::generate(queue, |q|
            match q.get_front {
                none() => none(),
                some(a) => some $ (q.pop_front, a)
            }
        ).to_dyn;
        chan.@var.mod(set_queue(RingBuffer::create([])));;
        pure $ iter
    )
};

// `channel.close` closes a channel.
// After close, `send()` will fail.
close: [m: MonadIO] Channel a -> m ();
close = |chan| lift_io $ do {
    chan.@var.mod(set_closed(true))
};

// `channel.is_closed` checks whether the channel is closed.
is_closed: [m: MonadIO] Channel a -> m Bool;
is_closed = |chan| lift_io $ do {
    let data = *chan.@var.get;
    pure $ data.@closed
};

// `channel.is_empty` checks whether the queue of the channel is empty.
is_empty: [m: MonadIO] Channel a -> m Bool;
is_empty = |chan| lift_io $ do {
    let data = *chan.@var.get;
    pure $ data.@queue.is_empty
};

// `channel.send(a)` sends a data to the queue of the channel.
// If the channel is closed, it throws `closed_error`.
send: [m: MonadIOFail] a -> Channel a -> m ();
send = |a, chan| lift_iofail $ do {
    chan.@var.lock(
        |data|
        if data.@closed {
            pure $ err $ closed_error
        };
        let data = data.mod_queue(push_back(a));
        chan.@var.Var::set(data);;
        pure $ ok $ ()
    ).lift.bind(from_result)
};

// `channel.recv` receives a data from the queue of the channel.
// If the queue is empty, it waits until any data is sent, or the channel is closed.
// If the channel is closed and the queue is empty, it throws `closed_error`.
recv: [m: MonadIOFail] Channel a -> m a;
recv = |chan| lift_iofail $ do {
    chan.@var.wait_and_lock(
        |data| data.@closed || !data.@queue.is_empty,
        |data|
        if data.@closed && data.@queue.is_empty {
            pure $ err $ closed_error
        };
        let a = data.@queue.get_front.as_some;
        let data = data.mod_queue(pop_front);
        chan.@var.Var::set(data);;
        pure $ ok $ a
    ).lift.bind(from_result)
};

// `channel.recv` tries to receive a data from a channel.
// If there is no data, `none` is returned.
// If the channel is closed and the queue is empty, it throws `closed_error`.
try_recv: [m: MonadIOFail] Channel a -> m (Option a);
try_recv = |chan| lift_iofail $ do {
    chan.@var.lock(
        |data|
        if data.@closed && data.@queue.is_empty {
            pure $ err $ closed_error
        };
        if data.@queue.is_empty {
            pure $ ok $ none()
        };
        let a = data.@queue.get_front.as_some;
        let data = data.mod_queue(pop_front);
        chan.@var.Var::set(data);;
        pure $ ok $ some(a)
    ).lift.bind(from_result)
};

// An error message which is reported when the channel is closed.
closed_error: ErrMsg;
closed_error = "Closed";
