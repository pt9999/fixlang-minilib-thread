// A task pool that can be used parallel computation.
//
// A task pool creates IOTasks and starts them.
// Each task waits for request until shutdown.
// When the task receives the request, it performs the request as a computation.
// When the task pool is shutdown, all tasks are stopped.
// Computations are never performed after shutdown.
//
module Minilib.Thread.TaskPool;

import AsyncTask;

import Minilib.Monad.IO;
import Minilib.Trait.Traversable;
import Minilib.Thread.Channel;
import Minilib.Thread.Future;

// A task pool that manages a collection of IOTasks.
type TaskPool = unbox struct {
    chan: Channel FutureToken,
    tasks: Array (IOTask ())
};

// `TaskPool::make(task_count)` creates a TaskPool.
make: [m: MonadIO] I64 -> m TaskPool;
make = |task_count| lift_io $ do {
    let chan = *Channel::make;
    let tasks = *Iterator::range(0, task_count).to_array.map_m(|i|
        AsyncIOTask::make(_task_func(chan))
    );
    pure $ TaskPool {
        chan: chan,
        tasks: tasks
    }
};

// Register a future.
// It sends a future token to the channel.
register_future: [m: MonadIOFail] FutureToken -> TaskPool -> m ();
register_future = |token, pool| lift_iofail $ do {
    pool.@chan.send(token)
};

// Cancel all pending futures and clears the queue.
cancel_all_pendings_futures: [m: MonadIO] TaskPool -> m ();
cancel_all_pendings_futures = |pool| lift_io $ do {
    // Cancell all pending futures
    let tokens = *pool.@chan.take_and_clear;
    tokens.foreach_m(set_state(FutureState::canceled()))
};

// Checks whether the taskpool has been shutdown.
is_shutdown: [m: MonadIO] TaskPool -> m Bool;
is_shutdown = |pool| lift_io $ do {
    pool.@chan.is_closed
};

// Shutdowns a taskpool.
shutdown: [m: MonadIO] TaskPool -> m TaskPool;
shutdown = |pool| lift_io $ do {
    // Close the channel
    pool.@chan.close;;

    // Wait for all tasks to finish
    pool.@tasks.to_iter.foreach_m(
        |task| task.get
    );;
    let pool = pool.set_tasks([]);

    // Cancell all pending futures and clears the queue.
    pool.cancel_all_pendings_futures;;
    pure $ pool
};

// The task function of the taskpool.
_task_func: Channel FutureToken -> IO ();
_task_func = |chan| (
    loop_m(
        (), |_|
        let token = *chan.recv;
        if *chan.is_closed.lift {
            // if channel was closed but the queue was not empty
            token.set_state(FutureState::canceled()).lift;;
            throw $ Channel::closed_error
        };
        token.set_state(FutureState::running()).lift;;
        token.@io_unit.lift;;
        token.set_state(FutureState::completed()).lift;;
        continue_m $ ()
    )
    .try(|err|
        if err == Channel::closed_error {
            pure()
        };
        eprintln(err)
    )
);
